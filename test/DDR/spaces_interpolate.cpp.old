#include <fstream>
#include <iostream>

#include "../testhelpers.hpp"
#include "../testfunctions.hpp"

#include "ddr_spaces.hpp"

#include "mesh_builder.hpp"

using namespace Manicore;

const char *meshfile = "../meshes/test/58_pts.json";
const char *mapfile = "meshes/test/libdisk_maps_debug_flat_hc.so";
//const char *mapfile = "meshes/test/libdisk_maps.so";

int main(int argc, char *argv[]) {

  Err_p err_p;
  NullStream os;
  constexpr size_t dimension = 2;
  constexpr bool use_thread = false;

  // Build the mesh
  std::unique_ptr<Mesh<dimension>> mesh_ptr(Mesh_builder<dimension>::build(meshfile,mapfile));
  
  char *p;
  size_t i_cell=std::strtol(argv[1],&p,10);

  /*
  auto compute_global_hodge = [&]<size_t k,size_t d>(size_t m_id, const Eigen::Vector<double,dimension> &x)->Eigen::Matrix<double,Dimension::ExtDim(d-k,d),Dimension::ExtDim(d-k,d)> {
    double sqrtdetG = mesh_ptr->volume_form(m_id,x)/Dimension::factorial(d-k);
    auto const partialDet = Compute_pullback<k,d,d>::compute(mesh_ptr->metric_inv(m_id,x));
    auto const & complBasis = ComplBasis<k,d>::compute();
    return sqrtdetG*complBasis*partialDet;
  };*/

  for (int r = 0; r < 1; ++r) {
    DDR_Spaces<dimension> ddr_spaces(*mesh_ptr,r,use_thread,nullptr,os);
    PEC<dimension> _ddr(*mesh_ptr,r,use_thread,nullptr,os);
    std::cout<<"Degree "<<r<<std::endl;

    auto compute_interp = [&]<size_t k>(auto const & T,size_t iT, Eigen::VectorXd const & interp, 
                                        auto const & P)->double {
      size_t constexpr d = std::remove_reference<decltype(T)>::type::cell_dim;
      Integral<dimension,d> integral(mesh_ptr.get());
      QuadratureRule<d> quad = integral.generate_quad(iT,12);
      Eigen::VectorXd PI = ddr_spaces.potential(k,d,iT)*ddr_spaces.dofspace(k).restrict(d,iT,interp);

      double err = 0.;
      for (size_t iqn = 0; iqn < quad.size(); ++iqn){
        // Manually evaluate PI
        Eigen::Vector<double,Dimension::ExtDim(d-k,d)> val_poly = Eigen::Vector<double,Dimension::ExtDim(d-k,d)>::Zero();
        for (size_t i_e = 0; i_e < Dimension::ExtDim(d-k,d); ++i_e) {
          for (size_t i_b = 0; i_b < Dimension::PolyDim(r,d); i_b++) {
            val_poly(i_e) += T.evaluate_poly_on_ref(quad[iqn].vector,i_b,r)*PI(i_e*Dimension::PolyDim(r,d) + i_b);
          }
        }
        auto Ix = T.evaluate_I(0,quad[iqn].vector);
        auto const trT = T.template evaluate_DI_p<k>(0,quad[iqn].vector);
        auto const hodge = mesh_ptr->template getHodge<k,d>(iT,quad[iqn].vector);
        // TODO use the correct mapping from T instead of i_cell
//        auto const hodge_global = compute_global_hodge.template operator()<dimension-k,dimension>(mesh_ptr->get_map_ids(dimension,i_cell)[0],Ix);
                auto const & Tc = mesh_ptr->template get_cell_map<dimension>(i_cell);
                auto const Jx = Tc.evaluate_J(0,Ix);
                auto const hodge_c = mesh_ptr->template getHodge<dimension-k,dimension>(i_cell,Jx);
          auto const trTinv = Tc.template evaluate_DJ_p<k>(0,Ix);
          auto const trTc = Tc.template evaluate_DI_p<dimension-k>(0,Jx);
        Eigen::Vector<double,Dimension::ExtDim(d-k,d)> val_w = hodge*trT*trTinv*hodge_c*trTc*P.template P_ev<dimension-k>(Ix);
        //Eigen::Vector<double,Dimension::ExtDim(d-k,d)> val_w = hodge*trT*P.template P_ev<k>(Ix);

   
   if constexpr(d==1&&k==1&&true) {
     std::cout<<"PI: "<<PI.transpose()<<std::endl;
     std::cout<<"P eval: "<<P.template P_ev<dimension-k>(Ix)<<std::endl;
     std::cout<<"trT: "<<trT<<std::endl;
     std::cout<<"Hodge: "<<hodge<<std::endl;
     std::cout<<"Hodge_c: "<<hodge_c<<std::endl;
     std::cout<<"trTinv: "<<trTinv<<std::endl;
     std::cout<<"val_w: "<<val_w<<std::endl;
     std::cout<<"val_poly: "<<val_poly<<std::endl;
     std::cout<<"\n"<<(trTc*P.template P_ev<dimension-k>(Ix)).transpose()<<std::endl;
     std::cout<<(hodge_c*trTc*P.template P_ev<dimension-k>(Ix)).transpose()<<std::endl;
     std::cout<<(trTinv*hodge_c*trTc*P.template P_ev<dimension-k>(Ix)).transpose()<<std::endl;
     std::cout<<(trT*trTinv*hodge_c*trTc*P.template P_ev<dimension-k>(Ix)).transpose()<<std::endl;
     std::cout<<(hodge*trT*trTinv*hodge_c*trTc*P.template P_ev<dimension-k>(Ix)).transpose()<<std::endl;
   }
   
        err += quad[iqn].w*(val_poly - val_w).dot(val_poly - val_w);
      }
      return err;
    };

    auto compute_diff = [&]<size_t k>(auto const & T,size_t iT, Eigen::VectorXd const & interp, 
                                        auto const & P)->double {
      size_t constexpr d = std::remove_reference<decltype(T)>::type::cell_dim;
      Integral<dimension,d> integral(mesh_ptr.get());
      QuadratureRule<d> quad = integral.generate_quad(iT,12);
      Eigen::VectorXd PI = ddr_spaces.full_diff(k,d,iT)*ddr_spaces.dofspace(k).restrict(d,iT,interp);

      double err = 0.;
      for (size_t iqn = 0; iqn < quad.size(); ++iqn){
        // Manually evaluate PI
        Eigen::Vector<double,Dimension::ExtDim(d-k-1,d)> val_poly = Eigen::Vector<double,Dimension::ExtDim(d-k-1,d)>::Zero();
        for (size_t i_e = 0; i_e < Dimension::ExtDim(d-k-1,d); ++i_e) {
          for (size_t i_b = 0; i_b < Dimension::PolyDim(r,d); i_b++) {
            val_poly(i_e) += T.evaluate_poly_on_ref(quad[iqn].vector,i_b,r)*PI(i_e*Dimension::PolyDim(r,d) + i_b);
          }
        }
        auto Ix = T.evaluate_I(0,quad[iqn].vector);
        auto const trT = T.template evaluate_DI_p<k+1>(0,quad[iqn].vector);
        auto const hodge = mesh_ptr->template getHodge<k+1,d>(iT,quad[iqn].vector);
        Eigen::Vector<double,Dimension::ExtDim(d-k-1,d)> val_dw = hodge*trT*P.template D_ev<k>(Ix);

        err += quad[iqn].w*(val_poly - val_dw).dot(val_poly - val_dw);
      }
      return err;
    };

    Poly_One poly{r}, poly_po{r+1}; //, poly_p2{r+2};
    Poly_One_trimmed trpoly_po{r+1}, trpoly_p2{r+2};
    auto const & T = mesh_ptr->template get_cell_map<dimension>(i_cell);
    PolyPullback poly_T(poly,T), poly_po_T(poly_po,T);
    PolyPullback trpoly_po_T(trpoly_po,T), trpoly_p2_T(trpoly_p2,T);

    auto test_interpolate = [&]<size_t _d>(auto && test_interpolate) {
      std::vector<size_t> boundaries = mesh_ptr->get_boundary(_d,dimension,i_cell);
      for (size_t i : boundaries) {
        std::cout<<"Dimension "<<_d<<" cell "<<i<<std::endl;
        auto const & F = mesh_ptr->template get_cell_map<_d>(i);

        auto test_interpolate_k = [&]<size_t _k>(auto && test_interpolate_k) {
          // Interpolate
          Eigen::VectorXd interp = ddr_spaces.template interpolate<_k>(
              [&](size_t m,const Eigen::Vector<double,dimension> &x)->Eigen::Vector<double,Manicore::Dimension::ExtDim(_k,dimension)> {
                //auto const hodge = compute_global_hodge.template operator()<dimension-_k,dimension>(mesh_ptr->get_map_ids(dimension,i_cell)[0],x);
                //return hodge*poly_T.template P_ev<dimension-_k>(x);
                auto const & T = mesh_ptr->template get_cell_map<dimension>(i_cell);
                auto const Jx = T.evaluate_J(0,x);
                auto const hodge = mesh_ptr->template getHodge<dimension-_k,dimension>(i_cell,Jx);
        auto const trTinv = T.template evaluate_DJ_p<_k>(0,x);
        auto const trT = T.template evaluate_DI_p<dimension-_k>(0,Jx);
                return trTinv*hodge*trT*poly_T.template P_ev<dimension-_k>(x);
                //return poly_T.template P_ev<_k>(x);
              });
          // TODO UPDATE
          Eigen::VectorXd interp_po = ddr_spaces.template interpolate<_k>(
              [&](size_t m,const Eigen::Vector<double,dimension> &x) {
                return poly_po_T.template P_ev<_k>(x);
              });
          Eigen::VectorXd diff = ddr_spaces.template interpolate<_k>(
              [&](size_t m,const Eigen::Vector<double,dimension> &x) {
                return trpoly_po_T.template P_ev<_k>(x);
              });
          Eigen::VectorXd diff_po = ddr_spaces.template interpolate<_k>(
              [&](size_t m,const Eigen::Vector<double,dimension> &x) {
                return trpoly_p2_T.template P_ev<_k>(x);
              });

          double err = compute_interp.template operator()<_k>(F,i,interp,poly_T);
          std::cout<<"Form degree: "<<_k<<std::endl;
          if (err > 1e-8) err_p++;
          std::cout<<"Test for potential"<<std::endl;
          std::cout<<"Error for P^r:     "<<err<<err_p<<std::endl;
 //         std::cout<<"Error for P^{r+1}: ";
 //         std::cout<<compute_interp.template operator()<_k>(F,i,interp_po,poly_po_T)<<std::endl;
          if constexpr (_k < _d) {
            std::cout<<"Test for differential"<<std::endl;
            err = compute_diff.template operator()<_k>(F,i,diff,trpoly_po_T);
            if (err > 1e-8) err_p++;
            std::cout<<"Error for P^{-,r+1}: "<<err<<err_p<<std::endl;
//            std::cout<<"Error for P^{-,r+2}: ";
//            std::cout<<compute_diff.template operator()<_k>(F,i,diff_po,trpoly_p2_T)<<std::endl;
          }

          if constexpr(_k < _d) test_interpolate_k.template operator()<_k+1>(test_interpolate_k);
        };
        test_interpolate_k.template operator()<0>(test_interpolate_k);
        std::cout<<std::endl;
      }

      if constexpr(_d < dimension) test_interpolate.template operator()<_d+1>(test_interpolate);
    };
    test_interpolate.template operator()<1>(test_interpolate);
  }

  std::cout<<"Number of unexpected results: "<< err_p._count<<std::endl;
  return err_p._count;
}

